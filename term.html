<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>Control de Versiones | Maestría en Desarrollo Web</title>

  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <link rel="stylesheet" href="reveal.js/css/theme/simple.css">
  <link rel="stylesheet" href="assets/css/font-awesome.min.css">
  <link rel="stylesheet" href="assets/css/custom.css">


  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

  <!-- Printing and PDF exports -->
  <script>
  var link = document.createElement( 'link' );
  link.rel = 'stylesheet';
  link.type = 'text/css';
  link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
  document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
</head>
<body>
  <div class="reveal">
    <div class="slides">
      <!-- Presentation -->
      <section>
        <h3>Maestría en Desarrollo Web</h3>
        <h2>Control de Versiones</h2>
        <h1>GIT, Terminología</h1>
        La terminología empleada puede variar de sistema a sistema,
        pero a continuación se describen algunos términos de uso común.
      </section>

      <!-- Terminologia -->
      <section id="terminologia">
        <section>
          <h3>Repositorio</h3>
          El repositorio es el lugar en el que se almacenan los datos actualizados
          e históricos de cambios, a menudo en un servidor. A veces se le denomina
          depósito o depot. Puede ser un sistema de archivos en un disco duro,
          un banco de datos, etc.
        </section>
        <section>
          <h3>Módulo</h3>
          Conjunto de directorios y/o archivos dentro del repositorio que
          pertenecen a un proyecto común.
        </section>
        <section>
          <h3>Revisión ("version")</h3>
          Darle a alguna versión de cada uno de los ficheros del módulo en desarrollo
          en un momento preciso un nombre común ("etiqueta" o "rótulo") para asegurarse
          de reencontrar ese estado de desarrollo posteriormente bajo ese nombre. En la
          práctica se rotula a todos los archivos en un momento determinado. Para eso el
          módulo se "congela" durante el rotulado para imponer una versión
          coherente. Pero bajo ciertas circunstancias puede ser necesario utilizar
          versiones de algunos ficheros que no coinciden temporalmente con las de los
          otros ficheros del módulo.
          Los tags permiten identificar de forma fácil revisiones importantes en el
          proyecto. Por ejemplo se suelen usar tags para identificar el contenido de
          las versiones publicadas del proyecto.

          En algunos sistemas se considera un tag como una rama en la que los
          ficheros no evolucionan, están congelados.
        </section>
        <section>
          <h3>Rotular ("tag")</h3>
          Darle a alguna versión de cada uno de los ficheros del módulo en desarrollo
          en un momento preciso un nombre común ("etiqueta" o "rótulo") para asegurarse
          de reencontrar ese estado de desarrollo posteriormente bajo ese nombre. En la
          práctica se rotula a todos los archivos en un momento determinado. Para eso el
          módulo se "congela" durante el rotulado para imponer una versión coherente. Pero
          bajo ciertas circunstancias puede ser necesario utilizar versiones de algunos
          ficheros que no coinciden temporalmente con las de los otros ficheros del módulo.

          Los tags permiten identificar de forma fácil revisiones importantes en el
          proyecto. Por ejemplo se suelen usar tags para identificar el contenido de las
          versiones publicadas del proyecto.

          En algunos sistemas se considera un tag como una rama en la que los ficheros
          no evolucionan, están congelados.
        </section>
        <section>
          <h3>Línea base ("baseline")</h3>
          Una revisión aprobada de un documento o fichero fuente, a partir del cual se
          pueden realizar cambios subsiguientes.
        </section>
        <section>
          <h3>Abrir rama ("branch") o ramificar</h3>
          Un módulo puede ser branched o bifurcado en un instante de tiempo de forma que,
          desde ese momento en adelante se tienen dos copias (ramas) que evolucionan de
          forma independiente siguiendo su propia línea de desarrollo. El módulo tiene
          entonces 2 (o más) "ramas". La ventaja es que se puede hacer un "merge" de las
          modificaciones de ambas ramas, posibilitando la creación de "ramas de prueba"
          que contengan código para evaluación, si se decide que las modificaciones
          realizadas en la "rama de prueba" sean preservadas, se hace un "merge" con la
          rama principal. Son motivos habituales para la creación de ramas la creación
          de nuevas funcionalidades o la corrección de errores.
        </section>
        <section>
          <h3>Desplegar ("Check-out", "checkout", "co")</h3>
          Un despliegue crea una copia de trabajo local desde el repositorio. Se puede especificar una revisión concreta, y predeterminadamente se suele obtener la última.
        </section>
        <section>
          <h3>"Publicar" o "Enviar" ("commit", "check-in", "ci", "install", "submit")</h3>
          Un <b>commit</b> sucede cuando una copia de los cambios hechos a una copia local es escrita o integrada sobre el repositorio.
        </section>
        <section>
          <h3>Conflicto</h3>
          Un conflicto ocurre cuando el sistema no puede manejar adecuadamente cambios realizados por dos o más usuarios en un mismo archivo. Por ejemplo, si se da esta secuencia de circunstancias:
          <ol>
            <li>Los usuarios <i>X</i> e <i>Y</i> despliegan versiones del <i>archivo A</i> en que las líneas <i>n1</i> hasta <i>n2</i> son comunes.</li>
            <li>El usuario <i>X</i> envía cambios entre las líneas <i>n1</i> y <i>n2</i> al <i>archivo A</i>.</li>
            <li>El usuario <i>Y</i> no actualiza el <i>archivo A</i> tras el envío del usuario <i>X</i>.</li>
            <li>El usuario <i>Y</i> realiza cambios entre las líneas <i>n1</i> y <i>n2</i>.</li>
            <li>El usuario <i>Y</i> intenta posteriormente enviar esos cambios al <i>archivo A</i>.</li>
          </ol>
          <p>El sistema es incapaz de fusionar los cambios. El usuario <i>Y</i> debe <i>resolver</i> el conflicto combinando los cambios, o eligiendo uno de ellos para descartar el otro.</p>
        </section>
        <section>
          <h3>Resolver</h3>
          El acto de la intervención del usuario para atender un conflicto entre diferentes cambios al mismo archivo.
        </section>
        <section>
          <h3>Cambio ("change", "diff", "delta")</h3>
          Un cambio representa una modificación específica a un archivo bajo control de versiones. La granularidad de la modificación considerada un cambio varía entre diferentes sistemas de control de versiones.
        </section>
        <section>
          <h3>Lista de cambios ("changelist", "change set", "patch")</h3>
          En muchos sistemas de control de versiones con commits multi-cambio atómicos, una lista de cambios identifica el conjunto de cambios hechos en un único commit. Esto también puede representar una vista secuencial del código fuente, permitiendo que el fuente sea examinado a partir de cualquier identificador de lista de cambios particular.
        </section>
        <section>
          <h3>Exportación ("export")</h3>
          Una exportación es similar a un check-out, salvo porque crea un árbol de directorios limpio sin los metadatos de control de versiones presentes en la copia de trabajo. Se utiliza a menudo de forma previa a la publicación de los contenidos.
        </section>
        <section>
          <h3>Importación ("import")</h3>
          Una importación es la acción de copia un árbol de directorios local (que no es en ese momento una copia de trabajo) en el repositorio por primera vez.
        </section>
        <section>
          <h3>Integración o fusión ("merge")</h3>
          Una <b>integración</b> o <b>fusión</b> une dos conjuntos de cambios sobre un fichero o un conjunto de ficheros en una revisión unificada de dicho fichero o ficheros.
          <ul>
            <li>Esto puede suceder cuando un usuario, trabajando en esos ficheros, <b>actualiza</b> su copia local con los cambios realizados, y añadidos al repositorio, por otros usuarios. Análogamente, este mismo proceso puede ocurrir en el repositorio cuando un usuario intenta <i><b>check-in</b></i> sus cambios.</li>
            <li>Puede suceder después de que el código haya sido <i><b>branched</b></i>, y un problema anterior al <i>branching</i> sea arreglado en una rama, y se necesite incorporar dicho arreglo en la otra.</li>
            <li>Puede suceder después de que los ficheros hayan sido <i><b>branched</b></i>, desarrollados de forma independiente por un tiempo, y que entonces se haya requerido que fueran fundidos de nuevo en un único <i>trunk</i> unificado.</li>
          </ul>
        </section>
        <section>
          <h3>Integración inversa</h3>
          El proceso de fundir ramas de diferentes equipos en el trunk principal del sistema de versiones.
        </section>
        <section>
          <h3>Actualización ("sync" ó "update")</h3>
          Una actualización integra los cambios que han sido hechos en el repositorio (por ejemplo por otras personas) en la copia de trabajo local.
        </section>
        <section>
          <h3>Copia de trabajo ("workspace")</h3>
          La copia de trabajo es la copia local de los ficheros de un repositorio, en un momento del tiempo o revisión específicos. Todo el trabajo realizado sobre los ficheros en un repositorio se realiza inicialmente sobre una copia de trabajo, de ahí su nombre. Conceptualmente, es un cajón de arena o sandbox.
        </section>
        <section>
          <h3>Congelar</h3>
          Significa permitir los últimos cambios (commits) para solucionar las fallas a resolver en una entrega (release) y suspender cualquier otro cambio antes de una entrega, con el fin de obtener una versión consistente. Si no se congela el repositorio, un desarrollador podría comenzar a resolver una falla cuya resolución no está prevista y cuya solución dé lugar a efectos colaterales imprevistos.
        </section>
      </section>

    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>
  // More info about config & dependencies:
  // - https://github.com/hakimel/reveal.js#configuration
  // - https://github.com/hakimel/reveal.js#dependencies
  Reveal.initialize({
    controls: false,
    slideNumber: true,
    dependencies: [
      { src: 'reveal.js/plugin/markdown/marked.js' },
      { src: 'reveal.js/plugin/markdown/markdown.js' },
      { src: 'reveal.js/plugin/notes/notes.js', async: true },
      { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
    ]
  });
  </script>
</body>
</html>
